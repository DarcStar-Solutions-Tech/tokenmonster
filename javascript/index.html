<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>TokenMonster Example</title>
  <style>
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f1f1f1;
}

#container {
  max-width: 1000px;
  margin: 0 auto;
  padding: 40px;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  border-radius: 8px;
}

#loadingBox {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px;
  border-radius: 10px;
  font-size: 20px;
}

h1 {
  text-align: center;
  font-size: 24px;
  margin-bottom: 20px;
}

.m {
  text-decoration:none;
  color:black;
  font-size:10pt;
}

#inputText {
  width: 100%;
  height: 180px;
  padding: 12px;
  box-sizing: border-box;
  border: 1px solid #ccc;
  border-radius: 4px;
  resize: vertical;
  background-color: #f9f9f9;
}

#output {
  width: 100%;
  padding: 12px;
  margin-top: 16px;
  background-color: #f9f9f9;
  border: 1px solid #ccc;
  border-radius: 4px;
}

#mbnote {
  visibility: hidden;
  margin-top: 16px;
  margin-bottom: 8px;
  font-style: italic;
  color: #777;
  font-size: 10pt;
  color: maroon;
}

.token {
  display: inline-block;
  padding: 0;
  margin: 0;
  padding-top: 2px;
  padding-bottom: 2px;
}

.token-0 {
  background-color: #90caf9;
}
.token-1 {
  background-color: #ffe082;
}
.token-2 {
  background-color: #a5d6a7;
}
.token-3 {
  background-color: #ff9ea9;
}


/* Improve the CSS for the dropdown boxes */
.select-wrapper {
  position: relative;
  display: inline-block;
  margin-bottom: 16px;
  width:280px;
}

.select-wrapper select {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  background: transparent;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 16px;
  width: 100%;
  cursor: pointer;
}

.select-wrapper::after {
  content: '\25BC';
  position: absolute;
  top: 50%;
  right: 12px;
  transform: translateY(-50%);
  pointer-events: none;
}

/* Apply the improved CSS classes to the dropdown boxes */

.output-container {
      display: flex;
      justify-content: space-between;
    }

    .output-box {
      width: 48%;
    }

    .token-count {
      margin-top: 16px;
    }
  </style>
  <script src="tokenmonster.js"></script> <!-- tokenmonster Encoder -->
  <script>

  function hasMultibyteCharacters() {
    const str = document.getElementById('inputText').value;
    let has = false;
    for (let i = 0; i < str.length; i++) {
      if (str.charCodeAt(i) > 127) {
        has = true;
        break;
      }
    }
    if (has) {
      document.getElementById("mbnote").style.visibility = "visible";
    } else {
      document.getElementById("mbnote").style.visibility = "hidden";
    }
  }
    // Load token data from the URL
    async function loadTokenData(tokenDataUrl) {
      const tokenMonster = new TokenMonster();
      try {
        // Load token data from the URL
        await tokenMonster.load(tokenDataUrl);
        return tokenMonster;
      } catch (error) {
        console.error('Error loading token data:', error);
        throw error;
      }
    }

    // Function to tokenize the text and apply background colors to tokens
    async function processInput(tokenizers, encoderNum) {
      const inputText = document.getElementById('inputText').value;
      const outputDiv = document.getElementById(`output-encoder-type-${encoderNum}`);
      const tokenCountDiv = document.getElementById(`token-count-encoder-type-${encoderNum}`);
      const encoderType = document.getElementById(`encoder-type-${encoderNum}`).value;
      const tokenizer = tokenizers[encoderType];

      try {
        // Tokenize the input text
        let tokens = [];
        tokens = tokenizer.tokenize(inputText);

        // Generate HTML with token boundaries highlighted
        let outputHTML = '';
        let tokenCount = 0;

        let decoder = tokenizer.Decoder()

        for (const tokenId of tokens) {
          // Detokenize each token individually
          let tokenStrDecoded = decoder.detokenize([tokenId]);
          
          // Replace space with HTML non-breaking space
          const htmlTokenStr = tokenStrDecoded.replace(/[&<>"'\t ]/g, match => ({'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;', '\t': '<tab/>', ' ': '&nbsp;'})[match]);

          outputHTML += `<span class="token token-${tokenCount % 4}">${htmlTokenStr.replace(/\n/g, `</span><br><span class="token token-${tokenCount % 4}">`)}</span>`;
          tokenCount++;
        }

        // Update the output div with the generated HTML
        outputDiv.innerHTML = outputHTML;

        // Update the token count div
        let avg = inputText.length / tokens.length;
        let avgFormatted = avg.toFixed(2);
        tokenCountDiv.innerText = `Characters: ${inputText.length}, Tokens: ${tokens.length}, Chr/Tok: ${avgFormatted}`;
      } catch (error) {
        console.error('Error tokenizing input:', error);
      }
    }

    // Entry point
    async function initialize() {
      const loadingMessageElement = document.getElementById('loadingBox');
      loadingMessageElement.style.display = 'block';

      // Load token data
      const tokenizers = {};
      await Promise.all([
        loadTokenData('english-100256-capcode.vocab').then(data => tokenizers['english-100256-capcode'] = data),
        loadTokenData('english-65536-capcode.vocab').then(data => tokenizers['english-65536-capcode'] = data),
        loadTokenData('english-50256-capcode.vocab').then(data => tokenizers['english-50256-capcode'] = data),
        loadTokenData('english-32000-capcode.vocab').then(data => tokenizers['english-32000-capcode'] = data),
        loadTokenData('code-100256-capcode.vocab').then(data => tokenizers['code-100256-capcode'] = data),
        loadTokenData('code-32000-capcode.vocab').then(data => tokenizers['code-32000-capcode'] = data),
        loadTokenData('english-100256.vocab').then(data => tokenizers['english-100256'] = data),
        loadTokenData('code-100256.vocab').then(data => tokenizers['code-100256'] = data),
        loadTokenData('code-50256.vocab').then(data => tokenizers['code-50256'] = data),
        loadTokenData('code-32000.vocab').then(data => tokenizers['code-32000'] = data)
      ]);

      loadingMessageElement.style.display = 'none';

      // Attach event handler to input element
      const inputTextElement = document.getElementById('inputText');
      inputTextElement.addEventListener('input', () => {
        processInput(tokenizers, '1');
        processInput(tokenizers, '2');
        hasMultibyteCharacters();
      });

      // Attach event handler to dropdown elements
      const encoderType1Element = document.getElementById('encoder-type-1');
      encoderType1Element.addEventListener('change', () => {
        processInput(tokenizers, '1');
      });

      const encoderType2Element = document.getElementById('encoder-type-2');
      encoderType2Element.addEventListener('change', () => {
        processInput(tokenizers, '2');
      });

      processInput(tokenizers, '1');
      processInput(tokenizers, '2');
    }

    // Initialize the page
    window.onload = initialize;
  </script>
</head>
<body>
  <div id="loadingBox">Loading...</div>
  <div id="container">
    <h1>tokenmonster test</h1>
    <div align="center" class="m">(<a href="https://platform.openai.com/tokenizer" target="_blank" class="m">compare with OpenAI tokenizer</a>)</div>
    <div id="mbnote">Note: Multi-byte characters are fully supported by TokenMonster but *not* fully supported by this viewer. As such you may see broken characters when using multi-byte text on this test page.</div>
    <textarea id="inputText" rows="5" cols="50"># Write anything here and you can see how it would be tokenized by TokenMonster.
# It's fun!

    class Decoder:
      def __init__(self, parent):
          self.parent = parent
          self.remainder = b''
          self.capcodeDecoder = capcode.Decoder
      def detokenize(self, tokens):
          if self.parent.charset == 0: # binary
              return self.parent.detokenize_bytes(tokens)
          decoded = self.remainder + b''.join(self.parent.id2word[id] for id in tokens if id in self.parent.id2word)
          if self.parent.charset == 1: # UTF-8
              invalidBytes = incomplete_utf8_bytes(decoded)
              decodedString = decoded[:len(decoded)-invalidBytes]
              decodedString = decoded.decode('utf-8')
          else:                        # UTF-16
              invalidBytes = incomplete_utf16_bytes(decoded)
              decodedString = decoded[:len(decoded)-invalidBytes]
              decodedString = decoded.decode('utf-16-le')
          self.remainder = decoded[len(decoded)-invalidBytes:]
          if self.parent.capcode:
              decodedString = self.capcodeDecoder.decode(decodedString)
          return decodedString
      </textarea>
    <div class="output-container">
      <div class="output-box">
        <div class="select-wrapper">
          <select id="encoder-type-1">
            <option value="english-100256-capcode" selected="selected">english-100256-capcode</option>
            <option value="english-65536-capcode">english-65536-capcode</option>
            <option value="english-50256-capcode">english-50256-capcode</option>
            <option value="english-32000-capcode">english-32000-capcode</option>
            <option value="code-100256-capcode">code-100256-capcode</option>
            <option value="code-32000-capcode">code-32000-capcode</option>
            <option value="english-100256">english-100256</option>
            <option value="code-100256">code-100256</option>
            <option value="code-50256">code-50256</option>
            <option value="code-32000">code-32000</option>
          </select>
        </div>
        <div id="output-encoder-type-1"></div>
        <div id="token-count-encoder-type-1" class="token-count"></div>
      </div>
      <div class="output-box">
        <div class="select-wrapper">
          <select id="encoder-type-2">
            <option value="english-100256-capcode">english-100256-capcode</option>
            <option value="english-65536-capcode">english-65536-capcode</option>
            <option value="english-50256-capcode">english-50256-capcode</option>
            <option value="english-32000-capcode">english-32000-capcode</option>
            <option value="code-100256-capcode">code-100256-capcode</option>
            <option value="code-32000-capcode">code-32000-capcode</option>
            <option value="english-100256">english-100256</option>
            <option value="code-100256">code-100256</option>
            <option value="code-50256">code-50256</option>
            <option value="code-32000" selected="selected">code-32000</option>
          </select>
        </div>
        <div id="output-encoder-type-2"></div>
        <div id="token-count-encoder-type-2" class="token-count"></div>
      </div>
      
    </div>
  </div>
</body>
</html>